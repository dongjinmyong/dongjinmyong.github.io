<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://dongjinmyong.github.io/</id><title>Pro-amateur</title><subtitle>JavaScript, developer, algorithm, react, Web, front-end, back-end, cat</subtitle> <updated>2022-01-25T11:00:58+09:00</updated> <author> <name>dongjinmyong</name> <uri>https://dongjinmyong.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://dongjinmyong.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="kr" href="https://dongjinmyong.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2022 dongjinmyong </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Heap Sort / 힙정렬</title><link href="https://dongjinmyong.github.io/posts/heap-sort/" rel="alternate" type="text/html" title="Heap Sort / 힙정렬" /><published>2022-01-25T00:00:00+09:00</published> <updated>2022-01-25T11:00:19+09:00</updated> <id>https://dongjinmyong.github.io/posts/heap-sort/</id> <content src="https://dongjinmyong.github.io/posts/heap-sort/" /> <author> <name>dongjinmyong</name> </author> <category term="algorithm" /> <summary> 문제 힙정렬은 최대힙 혹은 최소힙을 이용하는 정렬이다. 먼저 최대힙 혹은 최소힙을 만들어야 한다. 기본 개념 우선순위 큐 우선순위 개념을 큐에 도입한 자료구조. 즉 데이터들이 우선순위를 가지고 있어 우선순위가 높은 데이터가 먼저 나가는 자료구조이다. 스택, 큐, 우선순위 큐의 차이점은 아래와 같다. 자료구조 삭제되는 요소 스택 Stack 가장 최근에 들어온 데이터 큐 Queue 가장 먼저 들어온 데이터 우선순위 큐 Priority Queue 가장 우선순위가 높은 데이터 우선순위 큐는 배열, 연결리스트, 힙으로 구... </summary> </entry> <entry><title>LSCS / 연속부분배열의 최대합</title><link href="https://dongjinmyong.github.io/posts/LSCS/" rel="alternate" type="text/html" title="LSCS / 연속부분배열의 최대합" /><published>2022-01-18T00:00:00+09:00</published> <updated>2022-01-20T10:23:07+09:00</updated> <id>https://dongjinmyong.github.io/posts/LSCS/</id> <content src="https://dongjinmyong.github.io/posts/LSCS/" /> <author> <name>dongjinmyong</name> </author> <category term="algorithm" /> <summary> 문제 입력: 정수 배열 출력: 연속된 부분배열의 최대합 입출력 예시 let output = LSCS([1, 2, 3]); console.log(output); // --&amp;gt; 6 output = LSCS([1, 2, 3, -4]); console.log(output); // --&amp;gt; 6 ([1, 2, 3]) LSCS([1, 2, 3, -4, 5]); console.log(output); // --&amp;gt; 7 ([1, 2, 3, -4, 5]) LSCS([10, -11, 11]); console.log(output); // --&amp;gt; 11 ([11]) 분석 처음부터 하나씩 탐색을 할 때 음수를 만나는 경우 어떻게 처리할 것인가가 문제의 핵심이다. 첫 두 수가 [3, -2]라고 하자... </summary> </entry> <entry><title>Radix Sort / 기수정렬</title><link href="https://dongjinmyong.github.io/posts/Radix-Sort/" rel="alternate" type="text/html" title="Radix Sort / 기수정렬" /><published>2022-01-18T00:00:00+09:00</published> <updated>2022-01-18T00:00:00+09:00</updated> <id>https://dongjinmyong.github.io/posts/Radix-Sort/</id> <content src="https://dongjinmyong.github.io/posts/Radix-Sort/" /> <author> <name>dongjinmyong</name> </author> <category term="algorithm" /> <summary> 문제 정수 배열을 입력받아 오름차순 정렬한다. 입력: 170, 45, 75, 90, 802, 24, 2, 66 출력: 2, 24, 45, 66, 75, 90, 170, 802 기본로직 1의 자리 숫자를 기준으로 정렬한다. 170, 90, 802, 2, 24, 45, 75, 66 얻어진 배열을 10의 자리 숫자를 기준으로 정렬한다. 802, 2, 24, 45, 66, 75, 170, 90 다시 100의 자리 숫자를 기준으로 정렬한다. 2, 24, 45, 66, 75, 90, 170, 802 정렬 횟수는 입력값 중 가장 긴 수의 자릿수가 된다. 예제에서는 가장 긴 수인 170과 802의 길이가 3이고, 정렬 3번 만에 ... </summary> </entry> <entry><title>Counting Sort / 계수정렬</title><link href="https://dongjinmyong.github.io/posts/Counting-Sort/" rel="alternate" type="text/html" title="Counting Sort / 계수정렬" /><published>2022-01-18T00:00:00+09:00</published> <updated>2022-01-19T10:00:59+09:00</updated> <id>https://dongjinmyong.github.io/posts/Counting-Sort/</id> <content src="https://dongjinmyong.github.io/posts/Counting-Sort/" /> <author> <name>dongjinmyong</name> </author> <category term="algorithm" /> <summary> 문제 Counting Sort(계수 정렬)을 이용해 오름차순 정렬한다. 입력으로는 문자열이 될 수도 있고, 정수가 될 수도 있다. 먼저 정수배열을 오름차순으로 정렬해보도록 하자. 입력: [4, 3, 1, 3, 0, 9, 8] 출력: [0, 1, 3, 3, 4, 8, 9] 기본로직 수의 범위 [max, min]을 계산하고, 그만한 길이를 가지는 빈 배열을 만든다. 여기에 각 수들이 나타나는 횟수를 기록할 것이기 때문에 count라는 이름으로 배열을 만든다. 모든 값을 0으로 초기화한다. arr = [4, 3, 1, 3, 0, 9, 8] count = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] 입력 배열 arr이 정렬된 결과가 될 배열 output을 만든... </summary> </entry> <entry><title>Linux 심화 - 사용권한, 환경변수</title><link href="https://dongjinmyong.github.io/posts/Linux-Deep/" rel="alternate" type="text/html" title="Linux 심화 - 사용권한, 환경변수" /><published>2022-01-14T00:00:00+09:00</published> <updated>2022-01-17T15:43:40+09:00</updated> <id>https://dongjinmyong.github.io/posts/Linux-Deep/</id> <content src="https://dongjinmyong.github.io/posts/Linux-Deep/" /> <author> <name>dongjinmyong</name> </author> <category term="Linux" /> <summary> 사용권한 File Owner 리눅스에는 세 부류의 파일 소유자가 있다. Owner(혹은 User): 파일의 소유자(보통 파일을 만든 주체) Group: 여러 Owner(혹은 User)를 포함한다. 프로젝트를 진행하면서, 파일에 많은 사람이 액세스해야 하는 경우, 각 user에게 일일이 권한을 할당하는 대신 모든 user를 그룹으로 묶고 그룹에 권한을 할당한다. Others: owner도 아니고 group도 아닌 소유자이다. 소유자를 other로 설정하면 global한 설정이라고 볼 수 있다. 파일 소유자를 확인하는 방법: DJM ☠️ ~/jinyoung/codestates/environment_variable$ ls -al total 32 drwxr-xr-x 7 jin-ye... </summary> </entry> </feed>
