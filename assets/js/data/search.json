[ { "title": "Heap Sort / 힙정렬", "url": "/posts/heap-sort/", "categories": "algorithm", "tags": "JavaScript, RadixSort, 힙정렬, 정렬알고리즘, 최소힙, 최대힙", "date": "2022-01-25 00:00:00 +0900", "snippet": "문제힙정렬은 최대힙 혹은 최소힙을 이용하는 정렬이다.먼저 최대힙 혹은 최소힙을 만들어야 한다.기본 개념우선순위 큐우선순위 개념을 큐에 도입한 자료구조.즉 데이터들이 우선순위를 가지고 있어 우선순위가 높은 데이터가 먼저 나가는 자료구조이다.스택, 큐, 우선순위 큐의 차이점은 아래와 같다. 자료구조 삭제되는 요소 스택 Stack 가장 최근에 들어온 데이터 큐 Queue 가장 먼저 들어온 데이터 우선순위 큐 Priority Queue 가장 우선순위가 높은 데이터 우선순위 큐는 배열, 연결리스트, 힙으로 구현이 가능하다. 그 중 힙으로 하는 것이 가장 효율적이다. 구현방식 삽입 삭제 순서 없는 배열 O(1) O(n) 순서 없는 연결리스트 O(1) O(n) 정렬된 배열 O(n) O(1) 정렬된 연결리스트 O(n) O(1) 힙 O(logn) O(logn) 힙 Heap힙이란? 완전 이진트리의 일종으로 우선순위 큐를 위해 만들어진 자료구조.완전이진트리란? 마지막 레벨을 제외하고 모든 노드가 채워져 있으며, 마지막 레벨의 모든 노드는 가능한 왼쪽으로 채워져 있다. 마지막 레벨 h에서 $2^h - 1$개의 노드를 가질 수 있다.힙은 일종의 느슨한 정렬 상태(반정렬상태)를 유지하고 있다.부모 노드의 키 값이 자식 노드의 키 값보다 큰(작은) 이진트리라고 정의할 수 있겠다.이진 탐색트리에서는 중복값을 허용하지 않지만 힙 트리에서는 허용한다.힙의 구현 보통 배열을 사용한다. 쉬운 구현을 위해 배열의 첫 인덱스(0)는 사용하지 않는다. 특정 위치의 노드 번호는 변하지 않는다. 새로운 노드가 삽입되거나 노드가 삭제되어도 특정 노드의 번호는 변하지 않는다. 왼쪽 자식의 인덱스 = 부모 인덱스 _ 2오른쪽 자식의 인덱스 = 부모 인덱스 _ 2 + 1부모 인덱스 = (int) 자식 인덱스 / 2Javascript를 이용한 힙의 구현function swap(idx1, idx2, arr) { [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];}function getParentIdx(idx) { return Math.floor(idx / 2);}function insert(heap, item) { heap.push(item); let itemIdx = heap.length - 1; let parentIdx = getParentIdx(itemIdx); while (heap[parentIdx] &amp;lt; heap[itemIdx]) { swap(itemIdx, parentIdx, heap); itemIdx = parentIdx; parentIdx = getParentIdx(itemIdx); } return heap;}const binaryHeap = function (arr) { return arr.reduce((heap, item) =&amp;gt; { return insert(heap, item); },[Number.MAX_SAFE_INTEGER]).slice(1);};힙을 이용한 힙정렬function removeRoot(heap) { let end = heap.length; while (end &amp;gt; 0) { swap(0, end - 1, heap); // 제일 작은 값이 제일 뒤로 간다. end--; let curIdx; let minIdx = 0; while (curIdx !== minIdx) { curIdx = minIdx; let left = curIdx * 2 + 1; let right = curIdx * 2 + 2; if (left &amp;lt; end &amp;amp;&amp;amp; heap[left] &amp;lt; heap[minIdx]) { minIdx = left; } if (right &amp;lt; end &amp;amp;&amp;amp; heap[right] &amp;lt; heap[minIdx]) { minIdx = right; } swap(minIdx, curIdx, heap); } } return heap;}const heapSort = function (arr) { let minHeap = binaryHeap(arr); return removeRoot(minHeap).reverse();};" }, { "title": "LSCS / 연속부분배열의 최대합", "url": "/posts/LSCS/", "categories": "algorithm", "tags": "JavaScript, LSCS, 연속부분배열의 최대합, 알고리즘", "date": "2022-01-18 00:00:00 +0900", "snippet": "문제입력: 정수 배열출력: 연속된 부분배열의 최대합입출력 예시let output = LSCS([1, 2, 3]);console.log(output); // --&amp;gt; 6output = LSCS([1, 2, 3, -4]);console.log(output); // --&amp;gt; 6 ([1, 2, 3])LSCS([1, 2, 3, -4, 5]);console.log(output); // --&amp;gt; 7 ([1, 2, 3, -4, 5])LSCS([10, -11, 11]);console.log(output); // --&amp;gt; 11 ([11])분석처음부터 하나씩 탐색을 할 때 음수를 만나는 경우 어떻게 처리할 것인가가 문제의 핵심이다.첫 두 수가 [3, -2]라고 하자.현재로서는 -2를 선택할 이유가 없다. 왜냐하면 -2를 합하면 2를 빼는 것과 같기 때문이다.만약 다음 수가 음수라면 -2를 택할 이유는 더더구나 없다. 1이라면 어떨까. [3, -2, 1]이 되고 달라질 것은 없다. 1까지 선택하는 경우 최대합이 2가 되면서 첫 수 3만 선택한 것보다 작기 때문이다. 3이라면 다르다. [3, -2, 3]이 되고 이때에는 마지막 3까지 포함하는 것이 더 좋은 선택이 된다. 최대합이 4가 되며 첫 수 3만 선택했던 것보다 큰 합이 된다.이상의 사실에서 알 수 있는 것은직전까지의 부분최대합을 알고 있어야 한다는 것이다. 직전까지의 부분합과 현재의 값 중 큰 값을 알아야 한다.첫 수 3의 경우 부분최대합은 3이다.[3, -2]의 부분최대합은 3 + (-2)과 -2 중에서 큰 값이 1이 된다. 연속부분배열의 최대합은 3이다.다음 [3, -2, 1]의 부분최대합은 1 + 1과 1 중에서 큰 값인 2가 된다. 이제 부분최대합 2와 직전의 연속부분배열의 최대합 3을 비교해 큰 값을 택한다. 결과 연속부분배열의 최대합은 3이다.이런 식으로 부분최대합을 구해놓는 과정이 필요하다.코드 JavaScriptconst LSCS = function (arr) { let Sum = arr[0]; let subSum = arr[0]; for (let i = 1; i &amp;lt; arr.length; i++) { subSum = Math.max(subSum + arr[i], arr[i]); Sum = Math.max(Sum, subSum); } return Sum;};마무리실제 코드는 매우 짧다.DP 알고리즘 문제다. 부분문제의 결괏값으로부터 전체문제의 결괏값을 알 수 있기 때문이다. bottom-up 방식으로 하면서 DP 문제에서 흔하게 보는 저장배열을 사용하지 않은 특이한 케이스이다. 계산의 반복을 막기 위해 저장배열을 사용하는 것이 DP 알고리즘의 핵심 중 하나인데, 그 과정이 없으니 이 문제는 DP라고 봐야하는 지 모르겠다. 어쨌든 알고리즘 문제에서 기본이지만 어려운 ‘흔한’ 문제이다." }, { "title": "Radix Sort / 기수정렬", "url": "/posts/Radix-Sort/", "categories": "algorithm", "tags": "JavaScript, RadixSort, 기수정렬, 정렬알고리즘", "date": "2022-01-18 00:00:00 +0900", "snippet": "문제정수 배열을 입력받아 오름차순 정렬한다.입력: 170, 45, 75, 90, 802, 24, 2, 66출력: 2, 24, 45, 66, 75, 90, 170, 802기본로직 1의 자리 숫자를 기준으로 정렬한다. 170, 90, 802, 2, 24, 45, 75, 66 얻어진 배열을 10의 자리 숫자를 기준으로 정렬한다. 802, 2, 24, 45, 66, 75, 170, 90 다시 100의 자리 숫자를 기준으로 정렬한다. 2, 24, 45, 66, 75, 90, 170, 802 정렬 횟수는 입력값 중 가장 긴 수의 자릿수가 된다.예제에서는 가장 긴 수인 170과 802의 길이가 3이고, 정렬 3번 만에 결과를 얻는다. 각각의 정렬은 Counting Sort로 구현한다.계수 정렬을 사용하는 이유는 정렬하려는 값의 개수가 적을 때에는 계수정렬이 극한의 효율을 나타내기 때문이다.최대값이 k이고 입력 값의 개수가 n일 때, 계수 정렬의 시간복잡도는 n + k이다. Radix Sort에 내부에서 사용하는 정렬은 0~9, 10개의 숫자들의 비교이기 때문에 계수 정렬을 사용하는 것이 좋다.코드(JavaScript)countingSort = function (arr, exp) { const len = arr.length; const count = Array(10).fill(0); const output = Array(len).fill(0); for (let i = 0; i &amp;lt; len; i++) { count[Math.floor(arr[i] / exp) % 10]++; } for (let i = 1; i &amp;lt; 10; i++) { count[i] += count[i - 1]; } for (let i = len - 1; i &amp;gt;= 0; i--) { output[count[Math.floor(arr[i] / exp) % 10] - 1] = arr[i]; count[Math.floor(arr[i] / exp) % 10]--; } for (let i = 0; i &amp;lt; len; i++) { arr[i] = output[i]; }};radixSort = function (arr) { const posArr = []; const negArr = []; // 음수 배열, 양수 배열로 나누기 for (let item of arr) { if (item &amp;gt;= 0) posArr.push(item); else negArr.push(-item); } // 양수 배열을 정렬하기 let posMax = Math.max(...posArr); for (let exp = 1; Math.floor(posMax / exp) &amp;gt; 0; exp *= 10) { countingSort(posArr, exp); } // 음수 배열을 정렬하기 let negMax = Math.max(...negArr); for (let exp = 1; Math.floor(negMax / exp) &amp;gt; 0; exp *= 10) { countingSort(negArr, exp); } // 합쳐서 출력 return negArr .reverse() .map((item) =&amp;gt; -item) .concat(posArr);};추가 설명위 코드는 입력 배열이 음수를 포함하는 경우까지 고려했다.음수, 양수를 나누어 각각 정리한 다음, 최종적으로 붙여 출력했다." }, { "title": "Counting Sort / 계수정렬", "url": "/posts/Counting-Sort/", "categories": "algorithm", "tags": "JavaScript, CountingSort, 계수정렬, 정렬알고리즘", "date": "2022-01-18 00:00:00 +0900", "snippet": "문제Counting Sort(계수 정렬)을 이용해 오름차순 정렬한다.입력으로는 문자열이 될 수도 있고, 정수가 될 수도 있다.먼저 정수배열을 오름차순으로 정렬해보도록 하자.입력: [4, 3, 1, 3, 0, 9, 8]출력: [0, 1, 3, 3, 4, 8, 9]기본로직 수의 범위 [max, min]을 계산하고, 그만한 길이를 가지는 빈 배열을 만든다. 여기에 각 수들이 나타나는 횟수를 기록할 것이기 때문에 count라는 이름으로 배열을 만든다. 모든 값을 0으로 초기화한다. arr = [4, 3, 1, 3, 0, 9, 8]count = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] 입력 배열 arr이 정렬된 결과가 될 배열 output을 만든다. output = [0, 0, 0, 0, 0, 0, 0] count배열에 값을 넣는다. count[i]의 값은 arr 배열에서 i 값을 가지는 수의 개수이다. count = [1, 1, 0, 2, 1, 0, 0, 0, 1, 1] count 배열을 누적 배열(누적함수와 비슷)로 변환한다. count = [1, 2, 2, 4, 5, 5, 5, 5, 6, 7] 여기까지 진행하면 다음과 같은 관계가 성립한다.arr배열의 어떤 값 n이 output 배열에서 위치하는 인덱스는 count[n]이 된다. 예를 들어 arr배열의 수인 8은 count[8] = 6이므로 output배열의 6번째 위치에 있다. 익덱스로는 5번이다.이와 같은 관계를 확인했으므로 output배열에 값을 하나하나 넣어주면 된다. 이해하기 제일 어려웠던 부분이다. 따져 보면 맞긴 한데, 바로 코드로 작성하기에는 시간이 걸리는 부분이다. 외우자! for (let i = arr.length - 1; i &amp;gt;= 0; i++) { output[count[arr[i] - min] - 1] = arr[i]; count[arr[i] - min]--; // 같은 수가 여러개 있는 경우를 대비해} 코드(JavaScript)function countSort(arr) { const max = Math.max(...arr); const min = Math.min(...arr); const range = max - min + 1; const len = arr.length; const count = Array(range).fill(0); const output = Array(len).fill(0); for (let i = 0; i &amp;lt; len; i++) { count[arr[i] - min]++; } for (let i = 1; i &amp;lt; range; i++) { count[i] += count[i - 1]; } for (let i = len - 1; i &amp;gt;= 0; i--) { output[count[arr[i] - min] - 1] = arr[i]; count[arr[i] - min]--; } return output;}" }, { "title": "Linux 심화 - 사용권한, 환경변수", "url": "/posts/Linux-Deep/", "categories": "Linux", "tags": "Linux, CLI", "date": "2022-01-14 00:00:00 +0900", "snippet": "사용권한File Owner리눅스에는 세 부류의 파일 소유자가 있다. Owner(혹은 User): 파일의 소유자(보통 파일을 만든 주체) Group: 여러 Owner(혹은 User)를 포함한다.프로젝트를 진행하면서, 파일에 많은 사람이 액세스해야 하는 경우, 각 user에게 일일이 권한을 할당하는 대신 모든 user를 그룹으로 묶고 그룹에 권한을 할당한다. Others: owner도 아니고 group도 아닌 소유자이다.소유자를 other로 설정하면 global한 설정이라고 볼 수 있다.파일 소유자를 확인하는 방법: DJM ☠️ ~/jinyoung/codestates/environment_variable$ ls -altotal 32drwxr-xr-x 7 jin-yeonggim staff 224 12 13 13:54 .drwxr-xr-x@ 30 jin-yeonggim staff 960 12 13 13:38 ..-rw-r--r-- 1 jin-yeonggim staff 20 12 13 13:54 .env-rw-r--r-- 1 jin-yeonggim staff 84 12 13 13:57 index.jsdrwxr-xr-x 4 jin-yeonggim staff 128 12 13 13:49 node_modules-rw-r--r-- 1 jin-yeonggim staff 860 12 13 13:49 package-lock.json-rw-r--r-- 1 jin-yeonggim staff 265 12 13 13:49 package.json터미널에서 명령어 ls 뒤에 option으로 -al을 붙인다.출력된 결과를 해석하면 다음과 같다.drwxr-xr-x 4 jin-yeonggim staff 128 12 13 13:49# node_modules# ↓ ↓ ↓# Permission Owners GroupFile Permission▸ 파일 권한을 나타내는 결과는 위와 같은 길이가 10인 문자열이다. 첫 문자는 File의 Type을 나타낸다. 다음 9개의 문자는 세 개씩 끊어 읽어야 한다.각각 owner/user의 파일 권한, group의 파일 권한, others의 파일 권한을 나타낸다.drwxr-xr-x# d: 파일이냐 폴더냐 나타내는 자리# rwx: owner/user의 파일 권한을 나타내는 자리# r-x: group의 파일 권한을 나타내는 자리# r-x:: others의 파일 권한을 나나태는 자리▸ File Type은 다음과 같다. value File Type - 일반파일 d 디렉토리 파일 b 블록 디바이스 파일 c 문자 디바이스 파일 l 심볼릭 링크 파일 이 중에서 주로 - 와 d 를 사용한다.▸ 권한을 나타내는 세 개의 상태는 다음과 같다. 문자 의미 r read - 읽기 권한 w write - 쓰기 권한 x execute - 실행 권한 r, w, x이면 해당 권한이 있음을 나타내고, - 이면 해당 권한이 없음을 나타낸다.권한 변경 (Change File Permission)Linux 의 shell 에서 제공하는 chmod 명령어를 사용하여 파일의 권한을 변경할 수 있다.두 가지 방식으로 변경할 수 있다.Symbolic method+ 와 - , = 을 이용한 방법이다. Access Class Operator Access Type u(user) +(add access) r(read) g(group) -(remove access) w(write) o(other) =(set exact access) x(execute) a(all: u, g, 0)     예시:chmod a+r filename # 모든 사용자에게 읽기 권한 부여chmod +r filename # access class를 생략하면 기본값 all 적용chmod go-rw filename # group 과 others 에게서 읽기, 쓰기 권한을 제거chmod go=r filename # group 과 others 는 읽기 권한만 가진다.chmod o-w dirname # other 에게서 디렉터리 write 권한을 제거한다. rm 등을 사용할 수 없게 된다.Absolute methodrwx 를 이진수로 해석해 세자리 숫자로 표기하는 방법이다. 숫자 계산 문자표기 의미 7 4(r) + 2(w) + 1(x) rwx read, write and execute 6 4(r) + 2(w) + 0(-) rw- read and write 5 4(r) + 0(-) + 1(x) r-x read and execute 4 4(r) + 0(-) + 0(-) r– read only 3 0(-) + 2(w) + 1(x) -wx write and execute 2 0(-) + 2(w) + 0(-) -w- write only 1 0(-) + 0(-) + 1(x) –x execute only 0 0(-) + 0(-) + 0(-) — none 위 표에 케이스를 조합해 세자리 숫자로 사용 권한을 설정할 수 있다.chmod 744 myfile# 744 → rwxr--r--추가적인 내용은 링크를 통해 확인할 수 있다.sudo 와 susudo 명령어는 다른 user (기본적으로는 superuser - root) 보안 특권으로 프로그램을 실행할 수 있도록 한다. sudo 를 사용하면 user 나 group 이 root password 를 몰라도 몇몇(혹은 모든) 명령을 사용할 수 있게 된다.sudo commandsudo 를 사용하면 principle of least privilege(PoLP)를 쉽게 구현할 수 있다.su 는 switch user 의 줄임말이다.su usersu 뒤에 전환하고자 하는 계정 명을 쓴다.생략할 수도 있는데, 이 경우 시스템 관리자 계정인 root 로 설정된다.su 명령을 실행하면 전환하려고 하는 계정의 password 입력을 요구받게 된다.맥을 사용할 때 초기에는 root 에 password 가 설정되어 있지 않다.`root` 에 비밀번호를 설정하는 방법 sudo -s 를 입력하고 password 입력하라고 뜨면 현재 로그인 되어 있는 사용자 계정 비밀번호(맥북 부팅할 때 입력하는 비밀번호)를 입력한다. whoamiroot whoami 를 통해 현재 계정이 root 임을 확인할 수 있다. passwd root 를 입력하면 password를 입력하라고 뜨는데 여기에 root 비밀번호를 입력한다.한 번 더 입력하라고 하면 다시 입력해준다. su 명령어를 사용하는 것은 추천되지 않는데 root 계정으로 로그인하게 되면 시스템을 마음대로 바꿀 수 있기 때문에 예기치 못한 문제를 일으킬 수도 있기 때문이다.root 계정으로 로그인했다가 빠져나오려면 exit 명령어를 사용한다.sudo 와 su 의 차이 sudo 는 password 를 요구 받지 않고 명령을 한 번 실행한다. su 는 사용자를 root 로 바꾸어버린다.admin 과 user, root 사이 관계 root 는 시스템에 대한 모든 권한을 가지고 있는 superuser 이다. user 는 일반 유저 admin 도 user 이긴 한데 root 로부터 시스템 환경에 접근 및 수정할 수 있는 권한을 부여받은 유저이다. 사용자들이 시스템 안에서 하게 되는 일반적인 작업들(파일을 만들고, 프로그램을 돌리고, …)은 user 계정으로 실행하고 system 관련한 작업들(OS 환경설정 등)은 admin 이라는 계정을 통해 하도록 구분지은 것 뿐이다.linux를 잘 알면 좋은 점 업무 자동화 유리 aws 사용할 때 유리환경변수UNIX 환경변수rough하게 정의하면 운영체계가 굴러가는데 필요한 변수들의 모임이다.시스템에 정의된 환경변수를 확인하려면 터미널에 다음 명령어를 입력한다.export# printenv로도 조회가능하다# env로도 조회가능하다아무런 인자 없이 위와 같이 입력하면 OS 에 설정된 모든 환경변수들의 목록을 볼 수 있다.특정 환경변수의 값만 확인하고 싶을 때에는 echo 명령어를 사용한다.echo $환경변수명# echo 명령어를 사용할 때에는 환경변수명 앞에 $ 기호를 붙여야 한다.# printevn 명령어를 사용할 때에는 아래와 같이 한다.# printenv 사용할 때에는 변수명 앞에 $를 쓰지 않아도 된다.printenv 환경변수명# env로 특정 환경변수를 조회할 때에는 아래와 같이 grep을 사용한다.env | grep 환경변수명# 환경변수 이름에 공백이 있는 경우 따옴표로 감싸준다.echo $LANG# echo 명령어로 현재 쉘의 환경변수 뿐 아니라 시스템 전역변수도 읽을 수 있다.# 시스템 전역변수를 읽는 방법으로 printenv name 도 있다.을 입력하면ko_KR.UTF-8와 같은 결과를 얻게 된다.export 를 사용해 현재 터미널에서만 사용가능한 환경변수를 설정할 수도 있다.export name=value예를 들어export NickName=&#39;DongDong&#39;이라고 설정할 수 있다.다만 이렇게 설정한 환경변수는 현재의 터미널에서만 사용가능하다.이렇게 설정한 환경변수를 터미널을 끄거나 시스템을 재부팅하면 삭제된다.bash 쉘 변수를 특정 유저가 영구적으로 사용하도록 만들기 위해서는 ~/.bashrc 파일에 설정해줘야 한다. (실제 터미널에서 실험해봤는데 새롭게 설정한 변수가 초기화된다. 이유 확인 필요)bash 쉘 변수를 모든 유저가 영구적으로 사용하도록 만들기 위해서는 /etc/bash.bashrc 파일에 해당 변수를 추가 해줘야 한다. (이 경우에도 변수가 자꾸 초기화된다. 이유가 뭘까?)Node.js에서 환경변수 설정하기npm의 dotenv 모듈을 사용해 자바 스크립트에서 환경변수를 사용할 수 있다.아래와 같이 간단하게 node.js를 이용해 환경변수를 확인해보자.# terminal~$mkdir environment-test~$cd environment-test~/environment-test$npm init...# 여러 번 Enter를 치면서 node.js 프로젝트 초기설정을 해준다....# 자바 스크립트 파일을 만든다.~/environment-test$nano index.js# nano 편잡창에 js 코드를 작성하고 저장한다.# 작성한 내용 확인한다.~/environment-test$cat index.jsconsole.log(process.env);~/environment-test$node index.js# 환경변수를 담은 배열이 터미널에 출력될 것이다.node 프로젝트에 포한되어 있는 내장 객체 process.env 를 이용하면 시스템 환경변수에 접근할 수 있다.터미널에서 export 명령을 입력했을 때와 동일한 결과를 볼 수 있다.특정 환경변수을 조회하는 것도 가능하다.console.log(process.env.LANG); // ko_KR.UTF-8// process.env 객체를 사용하는 것은 node.js를 이용하는 프로젝트에 기본적으로 포함된 것으로 보인다.// 즉, npm init로 생성한 프로젝트에서 process.env를 사용할 수 있는 것 같다.node.js 환경에서 시스템 환경변수를 새롭게 설정하기 위해서는 dotenv 모듈을 사용해야 한다.npm i dotenv // 설치dotenv 모듈은 사용자가 작성한 .env 파일을 process.env 객체에 적용할 수 있도록 해준다..env 파일을 만들어 거기에 필요한 환경변수를 작성하고 나서 dotenv.config(); 를 생행하면 .env 파일에 정의된 환경변수가 process.env 객체에 추가된다.~/environment-test$nano .env# 환경변수 작성...# 작성 내용 확인~/environment-test$cat .envmyname=dongdong# 작성한 .env 파일을 process.env 객체에 추가하기 위한 js파일 작성~/environment-test$nano index.js...# 작성한 index.js 파일 내용 확인~/environment-test$cat index.jsconst dotenv = require(&#39;dotenv&#39;);dotenv.config();console.log(process.env.myname);# myname 이라는 환경변수가 설정됐는지 확인하기~/environment-test$node index.jsdongdong.env 파일은 환경변수이름=값 의 형태로 작성해야 한다.&#39;=&#39; 기호 앞뒤에는 공백이 없으며, 텍스트를 감싸는 어떠한 괄호도 없다.주의할 점.env 파일을 git에 올리면 안된다.제외 시키기 위해 git.ignore파일에 .env를 써줘야 한다.예를 들어 DB Password, 혹은 API Key의 값을 담고 있는 .env 파일을 웹에 올리게 되면 보안이 무너질 뿐 아니라, 해커가 심어놓은 봇을 통해 내 활동이 그대로 report될 수도 있다." }, { "title": "Matrix Rotation / 행렬회전", "url": "/posts/algorithm-Matrix-rotation/", "categories": "algorithm", "tags": "JavaScript, MatrixRotation", "date": "2022-01-14 00:00:00 +0900", "snippet": "문제n*m 크기의 행렬을 시계방향으로 90*k도 만큼 회전시킨 행렬을 구하는 알고리즘.행렬은 JS의 2차원 배열로 주어진다.const matrix = [ [1, 2, 3, 4], [3, 0, 9, 7], [2, 7, 8, 5],];console.log(rotateMatrix(matrix, 1)); // 1은 90 * 1도 만큼 회전한다는 뜻/*[ [2, 3, 1], [7, 0, 2], [8, 9, 3], [5, 7, 4]]*/분석크기가 n*m인 행렬을 90도 만큼 회전시키면 크기가 m*n인 행렬이 된다.또한, 90도 만큼 두 번 회전시키면 크기가 n*m인 행렬이 된다.즉 90도씩 몇 번 돌리냐에 따라 결과 행렬의 크기가 달라진다.일반화하여 표기하면k: 90도씩 회전하는 횟수n*m: 행렬의 크기k % 2 = 0 =&amp;gt; 결과행렬의 크기는 n*mk % 2 = 1 =&amp;gt; 결과행렬의 크기는 m*n회전 횟수에 따라 결과행렬의 크기가 가변적이므로, 이중 for문을 돌리면서 결과행렬의 값을 구할 때, index값의 범위도 가변적이다.그래서 회전횟수에 따라 iterator의 범위도 알맞게 정해지도록 하는 로직이 필요하다.로직은 아래 코드에서 확인.그 다음은 회전된 결과 행렬의 값을 구하는 로직이 필요하다.자세히 따져보면서 하면 되는데, 좀 많이 헷갈린다.자세한 설명은 주석 참고.코드로 구현한 알고리즘const rotateMatrix = function (matrix, rotateNum = 1) { let n = matrix.length; // 행의 수 let m = matrix[0] &amp;amp;&amp;amp; matrix[0].length; // 열의 수 const IJ = rotateNum % 2 ? [m, n] : [n, m]; // rotateNum에 따라 가변적으롤 정해지는 길이 2의 1차원 배열. // 0번 인덱스에는 결과행렬의 행의 수 // 1번 인덱스에는 결과행렬의 열의 수 let result = n === 0 ? [] : Array.from(Array(IJ[0]), () =&amp;gt; Array(IJ[1])); // 결과 행렬 선언, 초기값은 모두 undefined for (let i = 0; i &amp;lt; IJ[0]; i++) { for (let j = 0; j &amp;lt; IJ[1]; j++) { switch (rotateNum % 4) { case 0: // 회전할 필요가 없다. 원래 값을 그대로 할당한다 result[i][j] = matrix[i][j]; break; case 1: // 90도 회전할 때 로직 result[i][j] = matrix[n - 1 - j][i]; break; case 2: // 180도 회전할 때 로직 result[i][j] = matrix[n - 1 - i][m - 1 - j]; break; case 3: // 270도 회전할 때 로직 result[i][j] = matrix[j][m - 1 - i]; break; } } } return result;};실패 케이스빈 배열을 받았을 때 빈 배열을 리턴해야 한다.let result = Array.from(Array(IJ[0]), () =&amp;gt; Array(IJ[1]));이렇게 작성하면 빈배열을 받았을 때 [[]]이렇게 2차 배열을 리턴하게 된다.이것을 해결하기 위해서 빈배열일 때 빈 배열을 리턴하도록 하는 과정이 필요하다.let result = n === 0 ? [] : Array.from(Array(IJ[0]), () =&amp;gt; Array(IJ[1])이렇게 변경하여 해결했다." }, { "title": "백준 알고리즘 2529번 - 부등호", "url": "/posts/algorithm-InequalityNumber-Baekjoon-2529/", "categories": "algorithm, BOJ", "tags": "JavaScript, 백준알고리즘, 2529, dfs", "date": "2022-01-14 00:00:00 +0900", "snippet": "문제백준 알고리즘 2529번을 읽어보면 알 수 있겠지만, 이 문제는 주어진 일련의 부등호 사이에 숫자를 넣는 문제이다. 부등호 사이에 들어간 수들은 부등식 관계를 만족시켜야 한다.문제에서는 그러한 수들 중 가장 큰 수와 가장 작은 수를 구해야 한다.예를 들어 부등호 문자열이 &quot;&amp;gt; &amp;lt; &amp;lt; &amp;gt;&quot; 라고 주어졌을 때, 가장 큰 수는 96785(9&amp;gt;6&amp;lt;7&amp;lt;8&amp;gt;5), 가장 작은 수는 10243(1&amp;gt;0&amp;lt;2&amp;lt;4&amp;gt;)이다.분석일반적인 방식 9부터 적합한 위치에 찾아 넣는다(제일 작은 수를 구할 때에는 0부터) &amp;gt; 을 만나기 전까지 만난 &amp;lt; 의 갯수만큼 빈칸을 두어야 한다.즉 그 갯수만큼 앞에 위치할 숫자가 있다.(제일 작은 수를 구할 때에는 부호가 반대) 2에서 구한 숫자를 카운팅할 때, 왼쪽에서 오른쪽으로, 빈칸들만 카운팅한다(이미 채워진 자리들은 카운팅하지 않는다)DFS 방식코드로 구현방식let fs = require(&quot;fs&quot;);let input = fs.readFileSync(&quot;/dev/stdin&quot;).toString().split(&quot;\\n&quot;);const [count, signs] = input;let signArr = signs.split(&quot; &quot;);const len = signArr.length + 1;let maxArr = Array(len);let minArr = Array(len);let max = 9;let min = 0;while (max &amp;gt; 9 - len) { let step = 0; while (signArr.length &amp;amp;&amp;amp; signArr[step] === &quot;&amp;lt;&quot;) step++; let startIdx = 0; while (maxArr[startIdx] !== undefined) startIdx++; let i = startIdx; while (step &amp;gt; 0) { if (maxArr[i] === undefined) { i++; step--; } else { i++; } } maxArr[i] = max--; signArr.shift();}signArr = signs.split(&quot; &quot;);while (min &amp;lt; len) { let step = 0; while (signArr.length &amp;amp;&amp;amp; signArr[step] === &quot;&amp;gt;&quot;) step++; let startIdx = 0; while (minArr[startIdx] !== undefined) startIdx++; let i = startIdx; while (step &amp;gt; 0) { if (minArr[i] === undefined) { i++; step--; } else { i++; } } minArr[i] = min++; signArr.shift();}console.log(maxArr.join(&quot;&quot;));console.log(minArr.join(&quot;&quot;));DFS 방식마치며이 문제를 DFS로 접근할 수 있다고 하는 블로깅을 여럿 보았다.나는 DFS로 풀 생각을 선뜻 하지 못했다.하나하나 따지면서 수를 만들어나가는 방법이 있을 것 같다고 느꼈고, 결국 그렇게 풀었다.그러면 DFS로 풀지 않았다고 나쁜 코드라고 생각지는 않는다.실제로 백준에 제출한 결과가 나쁘지 않았다. node.js로 제출한 풀이 중에 3위에 랭킹되었다.실행시간이나 코드길이, 메모리 사용량이 나쁜지 않았다.다만 방식으로 풀면 일일히 따지기 귀찮다.chrome 개발자도구에 코드를 띄어 놓고 디버깅하면서 코드를 작성했다.시간이 많이 들었다. 거의 3시간 들었던 것 같다.이 정도 알고리즘 한 문제 푸는 데 3시간이라니…" }, { "title": "Web Server 기본", "url": "/posts/Base-of-Web/", "categories": "Web", "tags": "web, http, node.js, express", "date": "2022-01-14 00:00:00 +0900", "snippet": "목표Node.js를 이용하여 백엔드 서버를 구축한다. Node.js 기본개념, Node.js를 이용한 비동기작업 HTTP/네트워크 기초 및 응용 Node.js와 Express를 이용해 1의 내용을 구현한다. Server-side 디버깅 방법을 알아본다.Node.js 기본Node.js란 무엇인가?공식문서에 따르면 Node.js는 비동기로 작동하는 Java Script Runtime이다.스레드기반 네트워킹은 비효율적이고 다루기 어렵다.하지만 Node.js을 사용하면 데드락(dead-locking)을 걱정하지 않아도 된다.왜냐하면 Node.js는 Single Thread로 작동하기 때문이다. 또한 Node.js는 I/O에 직접적으로 영향을 미치는 함수가 없다.물론 Node.js Standard Library에는 Synchronous method가 있긴 하지만 Node.js의 가장 중요한 철학은 비동기, Asynchronous이다.Node.js는 Ruby(루비)의 Event Machine과 Python(파이썬)의 Twisted로부터 영감을 받았다고 한다.이벤트 모델을 좀 더 확장시켜 Event Loop을 만들었다. Event Loop으로 인해 Node.js의 비동기를 가능하게 되었다.Node.js는 REPL환경의 스크립트를 실행과 Event Loop을 동시에 실행한다.스크립트에는 비동기 API call, schedule timers 등과 같은 비동기 작업이 포함되어 있을 수 있는데 그러한 비동기 작업을 만나면 Event Loop 프로세스가 작동하게 된다.Event Loop은 timer, pending callbacks, idle prepare, poll, check, close callbacks 이렇게 6단계(phase)를 순회한다.각 단계는 FIFO로 작동하는 내부 큐를 가지고 있어서, Event Loop가 해당 phase에 들어오면 내부 큐에 있는 모든 callback함수를 실행한 후 다음 페이즈로 넘어간다. 자세한 내용은 생략.Node.js와 Web BrowserNode.js 이전에는 JavaScript를 실행할 수 있는 환경(Runtime)으로 Web Browser가 유일했다.이것은 JavaScript가 웹 브라우저를 통한 실시간 피드백이 가능하기 때문에 웹 프로그래밍에 효율적이라는 장점으로 작용한 동시에 웹 브라우저에 지나치게 의존한다는 치명적인 약점으로 작용했다.하지만 Node.js가 만들어짐으로써 로컬환경(우리의 PC 등)에서도 자바스크립트를 실행할 수 있게 되었다.Node.js의 출현은 자바스크립트는 가장 많이 사용되는 프로그래밍 언어로 자리매김할 수 있게 되었다.Node.js는 브라우저가 할 수 없는 몇 가지 작업도 가능하게 하는데 Node.js 내장모듈을 통해 모든 작업을 수행한다.Node.js로 개발을 한다는 것은 적절한 Node.js 내장 모듈을 어떻게 활용하는가의 문제이다.예를 들어, DNS에 대한 지식을 알고 있다면, DNS 모듈 사용법 문서에서 관련 메소드를 사용할 수 있다.Node.js fs모듈파일의 CRUD를 구현할 수 있는 모듈이다.html파일에서 외부 스크립트 파일을 불러올 때 다음과 같이 작성했다.&amp;lt;script src=&quot;불러오려고 하는 스크립트파일.js&quot;&amp;gt;&amp;lt;/script&amp;gt;Node.js에서 파일을 불러오기 위해서는 일단 fs모듈을 불러와야 한다.이렇게 불러온 모듈을 이용해 파일의 읽기, 쓰기 등의 작업을 하기 위해서는 해당 API문서를 읽어봐야 한다. 예를 들어 파일을 읽기 위해서는 readFile에서 사용방법을 찾아보면 될 것이고, 파일을 쓰기 위해서는 writeFile을 읽어보면 된다.Third-party 모듈(해당 프로그래밍 언어에서 공식적으로 제공하는 built-in 모듈이 아닌 외부에서 만든 모듈)을 Node.js에서 사용할 수 있는데 방법은 간단하다.npm install 외부모듈이름터미널 창에 위 명령을 실행시키면 외부모듈이 설치된다.fs모듈의 readFile 사용방법`fs.readFile(path[, options], callback)`API공식문서에는 `readFile`메소드의 문법이 위와 같이 나와있다.첫 번째 인자로 **파일의 위치**,두 번째 인자는 옵셥인데 여러가지 옵션을 설정할 수 있다.세 번째 인자는 콜백함수이다. path \\&amp;lt;string&amp;gt;|\\&amp;lt;Bufffer&amp;gt;|\\&amp;lt;URL&amp;gt;|\\&amp;lt;integer&amp;gt;path는 문자열, 버퍼, URL, 정수 이렇게 네 가지 타입의 값을 넣을 수 있지만 일반적으로는 문자열(&amp;lt;string&amp;gt;)타입을 넣는다. options \\&amp;lt;Object&amp;gt;|\\&amp;lt;string&amp;gt;options은 객체 또는 문자열로 넘길 수 있다.문자열로 넘길 경우 인코딩 방법을 넘긴다.let options = { encoding: &#39;utf-8&#39;, // UTF-8 인코딩 방식으로 파일을 연다. flag: &#39;r&#39; // 읽기 전용으로 파일을 연다}// 정의한 options에 맞춰 파일을 연다.fs.readFile(&#39;/etc/passwd&#39;, options, ...) // ...에는 콜백함수 callback \\&amp;lt;Function&amp;gt; err \\&amp;lt;Error&amp;gt; data \\&amp;lt;string&amp;gt;|\\&amp;lt;Buffer&amp;gt; 콜백함수는 파일을 다 읽고 난 후 비동기적으로 실행되는 함수이다.콜백함수에는 err, data 두 파라미터가 있다.파일읽기에 성공하면(에러가 발생하지 않으면) err는 null이 되고 data에는 Buffer라는 객체가 전달된다.options에 인코딩 방식이 정해져 있지 않다면 data 에 Buffer가 전달되고, utf-8과 같은 인코딩 방식이 정해져있다면 string이 전달된다. 예제_01// 01_callBack.jsconst fs = require(&quot;fs&quot;);const getDataFromFile = function (filePath, callback) { return fs.readFile(filePath, &quot;utf-8&quot;, (err, data) =&amp;gt; { if (err) { callback(err, null); } if (data) { callback(null, data); } });};// 정의된 함수 사용하기getDataFromFile(&quot;README.md&quot;, &quot;utf-8&quot;, (err, data) =&amp;gt; console.log(data));module.exports = { getDataFromFile,};예제_02// 02_promiseConstructor.jsconst fs = require(&quot;fs&quot;);const getDataFromFilePromise = function (filePath) { return new Promise((resolve, reject) =&amp;gt; { fs.readFile(filePath, &quot;utf-8&quot;, (err, data) =&amp;gt; { if (err) { reject(err); } if (data) { resolve(data); } }); });};// 사용하기getDataFromFilePromise(&quot;README.md&quot;).then((data) =&amp;gt; console.log(data));module.exports = { getDataFromFilePromise,};예제_03예제_02에서 작성한 함수를 이용하여 두 개의 파일을 비동기적으로 읽어서 내용을 하나의 배열에 넣는 예제이다.파일의 수가 늘어나면 Promise Hell이 열릴 것을 예상할 수 있다.// 03_basicChaning.jsconst path = require(&quot;path&quot;);const { getDataFromFilePromise } = require(&quot;02_promiseConstructor.js&quot;);const user1Path = path.join(__dirname, &quot;files/user1.json&quot;);const user2Path = path.join(__dirname, &quot;files/user2.json&quot;);const readAllUsersChaning = function () { return getDataFromFilePromise(user1Path) .then((file1) =&amp;gt; { return getDataFromFilePromise(user2Path).then((file2) =&amp;gt; { return `[${file1}, ${file2}]`; // [파일1, 파일2] 배열의 형태로 받기 위해 앞뒤에 []을 붙였다. 객체로 받고 싶다면 {}을 이용하면 된다. }); }) .then((text) =&amp;gt; JSON.parse(text));};// 사용하기readAllUsersChaning();modle.exports = { readAllUsersChaning,};[설명1]path.join()의 내용을 읽어보면 다음과 같다.path.join([...paths]) ...paths는 패스 세그먼츠 시퀀스 Returns: 문자열path.join(&quot;/foo&quot;, &quot;bar&quot;, &quot;baz/asdf&quot;, &quot;quux&quot;, &quot;..&quot;);// Returns: &#39;/foo/bar/baz/asdf&#39;path.join(&quot;foo&quot;, {}, &quot;bar&quot;);// Throws &#39;TypeError: Path must be a string. Received {}&#39;예시에서 보다시피 path.join()은 패스 세그먼트들을 연결한 path를 리턴한다.경로구분자(seperator)는 사용 플랫폼에 따라 자동으로 정해진다.Window라면 \\, MacOs라면 /으로 연결된다..은 현재 디렉토리, ..은 이전 디렉토리를 나타낸다.string이 아닌 입력에 대해서는 TypeError를 리턴한다.[설명2]__dirname: 현재 파일이 위치한 디렉토리의 절대경로__filename: 현재 파일을 포함한 파일의 절대위치예를 들어 example.js라는 파일의 위치가 /Users/me/temp/exampmle.js라면// file 명을 포함한 절대경로console.log(__filename); // /Users/me/temp/example.js// file 명을 제외한 절대 경로console.log(__dirname); // /Users/me/temppath에 대해 잘 설명한 글을 읽으면 좋다.예제_04예제_03에서 나타났던 Promise Hell을 Promise.all()을 이용하여 해결한다.// 04_promiseAll.jsconst path = require(&#39;path&#39;);const { getDataFromFilePromise } = require(&#39;./02_promiseConstructor&#39;);const user1Path = path.join(__dirname, &#39;files/user1.json&#39;);const user2Path = path.join(__dirname, &#39;files/user2.json&#39;);const readAllUsers = () =&amp;gt; { return Promise.all([ getDataFromFilePromise(user1Path); getDataFromFilePromise(user2Path); ]).then(result =&amp;gt; JSON.parse(`[${result}]`))}readAllUsers()module.exports = { readAllUsers}[설명]Promise.all() MDN문서을 참고하면Promise.all(iterable);는 iterable이 생략되지 않는 경우 반환되는 Promise의 이행 결과값은 iterable에 포함된 모든 값을 담을 배열이다.설명이 복잡한데, 예를 들어 세 개의 프로미스 p1, p2, p3를 배열로 담아 Promise.all()메소드의 파라미터로 넣으면 반환되는 프로미스의 이행 결과값은 각각의 프로미스의 이행 결과값을 담은 배열이 된다.이 점을 참고하면 예제_04에서 ${result}은 두 개의 프로미스의 목록이 된다. 목록을 배열에 담기 위해 앞뒤로 []을 붙였다.예제_05async와 await을 이용하면 예제_04보다 좀 더 직관적으로 비동기 작업을 구현할 수 있다.// 05_asyncAwait.jsconst { getDataFromFilePromise } = require(&quot;./02_promiseConstructor&quot;);const user1Path = path.join(__dirname, &quot;files/user1.json&quot;);const user2Path = path.join(__dirname, &quot;files/user2.json&quot;);const readAllUsersAsyncAwait = async () =&amp;gt; { let file1 = await getDataFromFilePromise(user1Path); let file2 = await getDataFromFilePromise(user2Path); let file = file1 + &quot;,&quot; + file2; return JSON.parse(`[${file}]`);};readAllUsersAsyncAwait();module.exports = { readAllUsersAsyncAwait,};코드가 아주 직관적으로 읽힌다.파일을 비동기적으로 읽기/primise-Promise.all() 이용cosnt fs = require(&#39;fs&#39;);const path = require(&#39;path&#39;);const user1Path = path.join(__dirname, &#39;files/user1.json&#39;);const user2Path = path.join(__dirname, &#39;files/user2.json&#39;);const readAllUsersChaning = function() { return getDataFromFilePromise(user1Path) .then(file1 =&amp;gt; { return getDataFromFilePromise(user2Path) .then(file2 =&amp;gt; { return `[${file1}, ${file2}]`; . }) }) .then(text =&amp;gt; JSON.parse(text));};const getDataFromFilePromise = filePath =&amp;gt; { return new Promise((resolve, reject) =&amp;gt; { fs.readFile(filePath, &#39;utf-8&#39;, (err, data) =&amp;gt; { if(err) { reject(err); } else { resolve(data); } }) })};const readAllUsers = () =&amp;gt; { return Promise.all([ getDataFromFilePromise(user1Path); getDataFromFilePromise(user2Path); ]).then(result =&amp;gt; JSON.parse(`[${result}]`))}readAllUsers()module.exports = { readAllUsers}파일을 비동기적으로 읽기/async-await 이용예제_02와 예제_05을 합쳐서 async-await로 파일을 읽는 함수를 만들어보자.const fs = require(&quot;fs&quot;);const path = require(&quot;path&quot;);const user1Path = path.join(__dirname, &quot;files/user1.json&quot;);const user2Path = path.join(__dirname, &quot;files/user2.json&quot;);const getDataFromFilePromise = (filePath) =&amp;gt; { return new Promise((resolve, reject) =&amp;gt; { fs.readFile(filePath, &quot;utf-8&quot;, (err, data) =&amp;gt; { if (err) { reject(err); } else { resolve(data); } }); });};const readAllUsersAsyncAwait = async () =&amp;gt; { let file1 = await getDataFromFilePromise(user1Path); let file2 = await getDataFromFilePromise(user2Path); let file = file1 + &quot;,&quot; + file2; return JSON.parse(`[${file}]`);};readAllUsersAsyncAwait();module.exports = { readAllUsersAsyncAwait,};Web API&#39;s fetchfetch요청은 대표적인 비동기 요청인 네트워크 요청이다.Node.js에서는 fetch모듈이 제공되지 않는다.네트워크 요청에는 다양한 형태가 있지만 가장 흔한 방식은 URL로 요청하는 방식이다.Node.js에서 URL을 통해 비동기 네트워크 요청을 가능하게 하는 API가 fetch API이다.예를 들어 fetch를 사용하여 Naver 메인화면에서 날씨 정보를 나타내는 엘리먼트에 필요한 정보를 외부 URL로부터 가져올 수 있다.아마도, 기상청에서 제공하는 정보를 해당 URL로부터 가져와 해당 DOM의 엘리먼트를 업데이트 하는 방식을 사용할 것이다.이러한 작업은 비동기적으로 이루어지는데 경우에 따라 실행시간이 오래 걸릴 수도 있으면 로딩되는 동안에 ‘로딩창’을 띄어주는 것을 항상 고려해야 한다.fetch는 비동기 작업이기 때문에 Promise형식으로 사용할 수 있다.fetch사용법fetch(&quot;http://example.com/movies.json&quot;) .then((response) =&amp;gt; response.json()) .then((data) =&amp;gt; console.log(data));fetch()는 data를 가져오려고 하는 URL, 하나의 파라미터를 가지며, init라는 optional한 파라미터도 있다. 자세한 내용은 fetch()를 참고.리턴값은 Response객체이며, 이는 HTTP응답전체를 담고 있는 객체이다.Reoponse객체로부터 Json형식의 데이터를 얻기 위해서는 Response객체의 메소드는 .json()을 사용하면 된다.text형식으로 데이터를 가져오기 위해서는 .text()메소드를 사용하면 된다.Response에 아주 상세하게 나와있다. 한 번쯤은 읽어보자.예제_01두 개의 URL로부터 데이터를 fetch한 다음 하나의 객체로 합치는 예제.지금은 두 개의 데이터이지만 데이터의 수가 많아지면 프로미스지옥이 생길 것을 예상할 수 있다.const newsURL = &#39;http://localhost:5000/data/lastestNews&#39;;const weatherURL = &#39;http://localhost:5000/data/weather&#39;;function getNewsAndWeather() { return fetch(newsURL) .then(news =&amp;gt; { return fetch(weatherURL) .then(weather =&amp;gt; { reutrn { news: news.data weather } }) })}if (typeof window === &#39;undefined&#39;) { module.exports = { getNewsAndWeatherAll }}// http://localhost:5000/data/lastestNews{ &quot;data&quot;: [ { &quot;row_id&quot;: 2, &quot;title&quot;: &quot;2021년 경제 성장률 전망 밝아&quot;, &quot;source&quot;: &quot;A신문&quot;, &quot;timestamp&quot;: &quot;2020/12/30&quot; }, { &quot;row_id&quot;: 3, &quot;title&quot;: &quot;코로나19 증가추세 대폭 하락해&quot;, &quot;source&quot;: &quot;BBC&quot;, &quot;timestamp&quot;: &quot;2020/12/29&quot; }, { &quot;row_id&quot;: 4, &quot;title&quot;: &quot;코드스테이츠 취업연계 파트너사 xxx건 돌파&quot;, &quot;source&quot;: &quot;스타트업 뉴스&quot;, &quot;timestamp&quot;: &quot;2020/12/31&quot; } ]}// http://localhost:5000/data/weather{ &quot;status&quot;: &quot;sunny&quot;, &quot;temperature&quot;: &quot;28&quot;, &quot;fineDust&quot;: &quot;good&quot;}예제_02예제_01의 내용을 Promise.all()을 이용하여 구현하기. 코드 리딩이 쉽다.const newsURL = &quot;http://localhost:5000/data/lastestNews&quot;;const weatherURL = &quot;http://localhost:5000/data/weather&quot;;function getNewsAndWeather() { return Promise.all([ fetch(newsURL).then((res) =&amp;gt; res.json()), fetch(weatherUR).then((res) =&amp;gt; res.json()), ]).then((result) =&amp;gt; { return { news: result[0].data, weather: result[1], }; });}if (typeof window === &quot;undefined&quot;) { module.exports = { getNewsAndWeatherAll, };}예제_03예제_02의 내용을 async, await을 이용하여 작성한다.var newsURL = &quot;http://localhost:5000/data/latestNews&quot;;var weatherURL = &quot;http://localhost:5000/data/weather&quot;;async function getNewsAndWeatherAsync() { let news = await fetch(newsURL).then((resp) =&amp;gt; resp.json()); let weather = await fetch(weatherURL).then((resp) =&amp;gt; resp.json()); return { news: news.data, weather, };}if (typeof window === &quot;undefined&quot;) { module.exports = { getNewsAndWeatherAsync, };}HTTP/네트워크 기초 및 응용HTTP/네트워크 기초클라이언트 - 서버 아키텍처모바일 쿠팡을 이용하여 쇼핑을 하는 경우를 생각해보자.검색어를 입력하여 검색하면 관련된 정보들이 잘 정리되어 보여진다.이 데이터가 우리 모바일 기기에 있는가? 아니다. 우리가 검색어를 입력하여 검색버튼을 누르는 순간, 우리의 요청이 쿠팡의 서버로 날아간다. 서버에서는 받은 요청에 맞는 데이터를 응답으로 보낸다. 서버에서 보낸 응답 데이터가 우리에게 보여진다.요즘은 이러한 인터넷 기반 애플리케이션이 흔하지만 예전에는 달랐다.데이터는 기기에 저장하고 이용했다.대표적인 사례는 차량 네비게이션이다.최신 교통정보를 사용하기 위해 정기적으로 서비스센터에 가서 네비게이션을 업데이트 해야했다.업데이트할 때 변경되거나 추가된 교통정보를 새롭게 다운로드받는 것이다.네비게이션은 그나마 업데이트를 통해 사용할 수 있지만 다른 서비스에는 제약이 많다.예를 들어 쇼핑몰 어플을 만든다면 실시간 결제 시스템이 필요한데 이것은 인터넷 없이 불가능하다.쿠팡앱과 같이 상품의 정보 같은 리소스가 존재하는 곳과 리소스를 사용하는 곳을 분리시킨 구조 혹은 그런 기술을 2티어 아키텍처 혹은 클라이언트-서버 아키텍처라고 한다.리소스를 사용하는 쪽이 클라이언트, 리소스를 제공하는 곳이 서버다.서버 쪽을 서버API(혹은 API서버)와 데이터베이스(DB)로 나누면 3티어 아키텍처가 된다.클라이언트에는 주로 웹사이트(웹앱), 스마트폰/태블릿 앱, 데스크탑 앱 등이 있다.서버에는 웹서버, 파일서버, 메일서버, DB서버 등이 있다.클라이언트 - 서버 통신클라이언트와 서버 간의 통신은 요청과 응답으로 이루어진다.요청이 있어야만 응답이 있다.클라이언트 - 서버 간 통신에 필요한 규약을 표준화한 것이 프로토콜이다.프로토콜은 일종의 약속으로서 이를 매뉴얼처럼 사용하여 정보를 주고 받는다.보통 웹 애플리케이션 아키텍처에서 클라이언트와 서버는 HTTP라는 프로토콜을 이용해 메시지를 주고 받는다.HTTP를 이용해 주고받는 메시지를 HTTP Message라고 한다.컴퓨터 공학과 네트워크 관련해서 기본적이고 중요한 내용이 OSI 7 Layers이다.한 번쯤 꼭 공부해봐야 한다.클라이언트가 어떠한 서버를 이용하기 위해서는 서버가 제공하는 API를 이용해야 한다.서버는 API를 통해 클라이언트가 서버를 이용할 수 있는 방법을 구현한 인터페이스(Interface)를 제공해야 한다. API(Application Programming Interface)인터넷을 통해 서버에 데이터를 요구할 때에는 HTTP 프로토콜을 사용하며, URL이나 URI를 통해 접근할 수 있다.요청을 보낼 때 메소드를 특정해줘야 하는데 가장 많이 쓰는 메소드는 GET, POST, PUT, PATCH, DELETE가 있다. 자세한 내용은 HTTP요청메서드(MDN문서)를 참고.URL과 URIURL은 Uniform Resource Locator의 약자로, 네트워크 상에서 웹 페이지, 이미지, 동영상 등의 파일이 위치한 정보를 나타낸다.URI는 Uniform Resource Identifier의 약자로, URL의 기본적인 요소인 scheme, hosts, url-path에 더해 query, bookmaker를 포함한다.즉 URI가 URL의 상위 카테고리이다.위 이미지에 잘 설명되어 있다. scheme은 통신 프로토콜을 결정한다. 일반적으로 웹 브라우저에서는 http나 https를 사용한다. domain은 subdomain, top-level domain 등으로 나눌 수도 있다.domain name을 IP주소로 대체할 수도 있다.원래는 어떤 서버이든지 고유의 IP주소가 있다.IPv4, IPv6 두 버전이 있는데 IPv4는 0~255의 범위를 가지는 세 자리수 네 개로 이루어진다(예: 168.126.01.3)이다. 대략 43억 개의 IP주소를 생성할 수 있다.IPv4로 부족하기 때문에 나온 것이 IPv6인데 2^128개의 IP주소를 생성할 수 있다.IP주소는 읽기 힘들기 때문에 DNS(Domain Name System)를 통해 domain name으로 바꾸어 사용한다.125.209.222.142 &amp;lt;- naver.com웹 브라우저에 naver.com 이라고 치면 DNS가 해당 도메인의 IP주소로 연결시켜준다. path(혹은 url-path)는 웹 서버의 루트 디렉토리부터 시작하여 웹 페이지, 동영상, 이미지 등이 위치한 경로와 파일명을 나타낸다. query를 이용해 웹 서버에 추가 질문을 할 수 있다. fragment는 웹 페이지 상에 위치한 앵커 포인트를 나타낸다.프래그먼트를 잘 설명한 글이 있어 여기 남겨둔다.HTTP MessageMDN문서에 아주 상세하게 나와 있다.간단하게 요약해보자① Request Message Start Line method: GET, PUT, POST, DELETE 등 url: method에 따라 다르다 origin 형식: ?와 쿼리 문자열이 붙는 절대 경로이다.예: POST / HTTP 1.1GET /background.png HTTP/1.0HEAD /test.html?query=alibaba HTTP/1.1OPTIONS /anypage.html HTTP/1.0 absolute 형식완전한 URL형식, 프록시에 연결하는 경우 대부분 GET과 함께 사용된다.예: GET http://developer.mozilla.org/en-US/docs/Web/HTTP/Messages HTTP/1.1 autority 형식도메인 이름 및 옵션 포트(‘:’가 앞에 붙는다)로 이루어진 URL의 authority component 이다.HTTP 터널을 구축하는 경우에만 CONNECT와 함께 사용할 수 있습니다.예제: CONNECT developer.mozilla.org:80 HTTP/1.1 asterisk 형식OPTIONS와 함께 별표(‘_’) 하나로 간단하게 서버 전체를 나타낸다.예: OPTIONS _ HTTP/1.1 protocol version Headers다양한 종류의 헤더가 있는데 세 종류로 나눌 수 있다. General 헤더 - message 전체에 적용된다. Request 헤더 - 요청의 내용을 좀 더 구체화시키거나 컨텍스(Referer)를 제공하거나 제약사항을 설정하여 요청의 내용을 수정하는 역할을 한다 Entity 헤더 - Request Body 에 적용되는 헤더이다.그러므로 Body가 없으면 Entity 헤더도 전송되지 않는다.예: Content-Type: text-plainContent-Length: 350 BodyGET, HEAD, DELETE, OPTIONS 처럼 리소스를 가져오는 요청은 본문이 필요하지 않다. 단일 리소스 본문(single-resource bodies): Content-Type과 Content-Length로 정의된 단일 파일로 구성된 본문 다중 리소스 본문(multiple-resource bodies): HTTP Form과 관련된다. ② Response Message Status line 상태줄다음과 같은 정보를 담고 있다 프로토콜 버전: 보통 HTTP/1.1이다 상태코드: 요청의 성공여부를 나타낸다. 200, 404, 302 등 상태 텍스트: 짧고 간결하게 상태코드에 대한 설명한 글예: HTTP/1.1 404 Not Found. Headers요청 메시지의 Header와 같다 Body크게 세 가지 종류로 나뉜다 이미 길이가 알려진 단일 파일로 구성된 single-resource bodies로서 두 개의 헤더(Content-Type, Content-Length)로 정의한다. 길이를 모르는 단일 파일로 구성된 single-resource bodies로서 chunked로 연결되어 있으며, 파일이 청크로 나뉘어 인코딩되어 있다. 서로 다른 정보를 담은 multiple-resource bodies로서 자주 보이지는 않는다. 읽어봐야 할 글 브라우저는 어떻게 작동하는가? MIME 타입브라우저의 작동원리AJAXAJAX는 Asynchronous JavaScript And XMLHttpRequest의 약자로, JavaScript, DOM, Fetch, XMLHttpReqest, HTML 등의 다양한 기술을 사용하는 웹 개발 기법이다.AJAX의 가장 큰 특징은 웹 페이지에 필요한 부분에 필요한 데이터만 비동기적으로 받아와 화면에 그려낼 수 있다는 것이다. AJAX의 두 가지 핵심 기술 JavaScript와 DOM전통적인 웹 어플리케이션에서는 &amp;lt;form&amp;gt; 태그를 이용해 서버에 데이터를 전송해야 했다. 또한 서버는 요청에 대한 응답으로 새로운 웹 페이지를 제공해주어야 했다. 다시 말해, 클라이언트에서 요청을 보내면 매번 새로운 페이지로 이동해야 했다.그러나 Fetch를 사용하면, 페이지를 이동하지 않아도 서버로부터 필요한 데이터를 받아올 수 있다. Fetch는 사용자가 현재 페이지에서 작업을 하는 동안 서버와 통신할 수 있도록 한다. 즉, 브라우저는 Fetch가 서버에 요청을 보내고 응답을 받을때까지 모든 동작을 멈추는 것이 아니라, 계속해서 페이지를 사용할 수 있게 하는 비동기적인 방식을 사용한다.또한 자바스크립트에서 DOM을 사용해 조작할 수 있기 때문에, Fetch를 통해 전체 페이지가 아닌 필요한 데이터만 가져와 DOM에 적용시켜 새로운 페이지로 이동하지 않고 기존 페이지에서 필요한 부분만 변경할 수 있습니다. XHR과 FetchFetch는 XHR의 단점을 보완한 새로운 Web이며, XML보다 가볍다.JavaScript와 호환되는 JSON을 사용한다.Fetch 예제 // Fetch를 사용fetch(&#39;http://52.78.213.9:3000/messages&#39;) .then (function(response) { return response.json(); }) .then(function (json) { ...}); AJAX의 장점 서버에서 HTML을 완성하여 보내주지 않아도 된다. 필요한 데이터를 비동기적으로 가져와 브라우저의 일부만 업데이트 하여 렌더링하는 방식으로 작동한다. 브라우저에 상관없이 AJAX를 사용할 수 있게 되었다 상호작용이 많은 어플리케이션 개발에 유용하다. 빠르다. 필요한 데이터를 텍스트 형태(JSON, XML 등)로 보내기 때문에 대역폭(네트워크 통신에서 한 번에 보낼 수 있는 데이터의 크기)이 작아도 된다. AJAX의 단점 SEO Search Engine Optimization 에 불리하다AJAX 방식의 웹 어플리케이션은 한 번 받은 HTML을 렌더링 한 후, 서버에서 비동기적으로 필요한 데이터를 가져와 리렌더링하기 때문에 처음 받는 HTML파일에는 데이터를 채울 ‘그릇’만 작성되어 있는 경우가 많다.검색엔진은 전세계 사이트의 정보를 수집하는데 AJAX 방식의 웹 어플리케이션의 HTML파일에는 데이터가 없기 때문에 검색엔진에 데이터를 제공하지 못한다. 뒤로가기 버튼 문제AJAX에서는 이전 상태를 기억하지 않는다.뒤로가기 기능을 구현하기 위해서는 별도의 History API를 사용해야 한다. SSR과 CSR SSR은 Server Side Rendering의 줄임말이다. 웹 페이지를 브라우저에서 렌더링하는 대신에, 서버에서 렌더링한다. 브라우저가 서버의 URI로 GET 요청을 보내면, 서버는 정해진 웹 페이지 파일을 브라우저로 전송한다. 그리고 서버의 웹 페이지가 브라우저에 도착하면 완전히 렌더링된다. 서버에서 웹 페이지를 브라우저로 보내기 전에, 서버에서 완전히 렌더링했기 때문에 Server Side Rendering 이라고 한다. 웹 페이지의 내용에 데이터베이스의 데이터가 필요한 경우, 서버는 데이터베이스의 데이터를 불러온 다음 웹 페이지를 완전히 렌더링 된 페이지로 변환한 후에 브라우저에 응답으로 보낸다. 웹 페이지를 살펴보던 사용자가, 브라우저의 다른 경로로 이동하면 어떻게 될까? 브라우저가 다른 경로로 이동할 때마다 서버는 이 작업을 다시 수행한다. CSR은 Client Side Rendering 을 의미한다. 일반적으로 CSR은 SSR의 반대로 여겨진다. SSR이 서버 측에서 페이지를 렌더링한다면, CSR은 클라이언트에서 페이지를 렌더링한다. 웹 개발에서 사용하는 대표적인 클라이언트는 웹 브라우저이다. 브라우저의 요청을 서버로 보내면 서버는 웹 페이지를 렌더링하는 대신, 웹 페이지의 골격이 될 단일 페이지를 클라이언트에 보낸다. 이때 서버는 웹 페이지와 함께 JavaScript 파일을 보낸다. 클라이언트가 웹 페이지를 받으면, 웹 페이지와 함께 전달된 JavaScript 파일은 브라우저에서 웹 페이지를 완전히 렌더링 된 페이지로 바꾼다. 웹 페이지에 필요한 내용이 데이터베이스에 저장된 데이터인 경우에는 어떻게 해야 할까? 브라우저는 데이터베이스에 저장된 데이터를 가져와서 웹 페이지에 렌더링을 해야 한다. 이를 위해 API가 사용된다. 웹 페이지를 렌더링하는 데에 필요한 데이터를 API 요청으로 해소한다. 마지막으로, 브라우저가 다른 경로로 이동하면 어떻게 될까? CSR에서는 SSR과 다르게, 서버가 웹 페이지를 다시 보내지 않는다. 브라우저는 브라우저가 요청한 경로에 따라 페이지를 다시 렌더링한다. 이때 보이는 웹 페이지의 파일은 맨 처음 서버로부터 전달받은 웹 페이지 파일과 동일한 파일이다. SSR과 CSR을 사용해야 하는 경우 Use SSR SEO(Search Engine Optimization) 가 우선순위인 경우, 일반적으로 SSR(Server Side Rendering) 을 사용한다. 웹 페이지의 첫 화면 렌더링이 빠르게 필요한 경우에도, 단일 파일의 용량이 작은 SSR 이 적합하다. 웹 페이지가 사용자와 상호작용이 적은 경우, SSR 을 활용할 수 있다. Use CSR SEO 가 우선순위가 아닌 경우, CSR을 이용할 수 있다. 사이트에 풍부한 상호 작용이 있는 경우, CSR 은 빠른 라우팅으로 강력한 사용자 경험을 제공한다. 웹 애플리케이션을 제작하는 경우, CSR을 이용해 더 나은 사용자 경험(빠른 동적 렌더링 등)을 제공할 수 있다. " } ]
